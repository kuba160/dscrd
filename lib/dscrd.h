/*
 *     dscrd: Discord C library
 *     Copyright (C) 2018 Jakub Wasylk√≥w
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
// This file was autogenerated by gen_dscrd_h.sh.

// common.h

#ifndef uint8_t
#include <stdint.h>
#endif
#ifndef bool
#include <stdbool.h>
#endif

/**
 * Discord API version library was compiled for
 *
 */
#define DISCORD_API 6

// needed for types which come before client.h
struct DiscordClient_s;

// http methods already defined by rest library
#ifndef REST_CLIENT_H_
/**
 * @brief HTTP Methods
 *
 * HTTP Methods which can be used to call REST library.
 */
enum http_method {
	HTTP_POST, HTTP_GET, HTTP_PUT, HTTP_DELETE, HTTP_HEAD, HTTP_OPTIONS, HTTP_PATCH
};
#endif

/**
 * @brief Discord datatypes
 *
 * @see dscrd_type_e for detailed element documentation.
 */
typedef enum dscrd_type_e {
	/// 0 element, will be set if uninitialized, therefore ignored
	DSCRD_TYPE_FIRST,
	/// @ref DiscordGuild
	DSCRD_GUILD,
	/// @ref DiscordChannel
	DSCRD_CHANNEL,
	/// @ref DiscordUser
	DSCRD_USER,
	/// @ref Webhook
	DSCRD_WEBHOOK,
	/// @ref DiscordClient
	DSCRD_CLIENT,
	/// @ref RestResp
	DSCRD_REST_RESP,
	// ignoring list types
	/// @ref DscrdFile
	DSCRD_FILE,
	/// @ref DiscordMessage
	DSCRD_MESSAGE,
	/// indicates last value of types
	DSCRD_TYPE_LAST,
	///
	DSCRD_TYPE_LIST = 256
} dscrd_type;

/**
 * Checks if library has gateway support.
 *
 * @returns 0 if library was compiled without gateway support, all gateway functions will fail
 * @returns 1 if library supports Gateway API
 * @see DiscordClient_gateway() - to be called if Gateway API will be used
 */
int dscrd_has_gateway (void);

/**
 * Read last error message.
 *
 * @see dscrd_error_long
 */
const char * dscrd_error (void);

/**
 * Read last error message.
 * In comparison to @ref dscrd_error() this function will show in what function error happened.
 *
 * @see dscrd_error
 */
const char * dscrd_error_long (void);

/**
 * Overwrite library API version dscrd uses.
 * For current Discord API version look https://discordapp.com/developers/docs/reference#api-versioning-api-versions
 * @param api API version number
 * @see DISCORD_API
 */
void dscrd_overwrite_api (int api);

/**
 * Initialize dscrd library. You should call this function before calling any other function.
 * 
 * @returns 0 on success
 * @see dscrd_terminate
 * @note At the time of writing this function always returns 0.
 */
int dscrd_initialize (void);

/**
 * Terminate dscrd library. Call this function if you're done with dscrd library. 
 * You should not call any library function after this function.
 * 
 * @returns 0 on success
 * @see dscrd_initialize
 * @note At the time of writing this function always returns 0.
 */
int dscrd_terminate (void);

//
// Things which hard to assign somewhere else...
//

enum dscrd_verification_level {
	/// unrestricted
	NONE,
	/// must have verified email on account
	LOW,
	/// must be registered on Discord for longer than 5 minutes
	MEDIUM,
	/// must be a member of the server for longer than 10 minutes
	HIGH,
	/// must have a verified phone number
	VERY_HIGH
};

/**
 * @brief Permissions also described at https://discordapp.com/developers/docs/topics/permissions
 */
typedef enum permissions_e {
	/// Allows creation of instant invites
	CREATE_INSTANT_INVITE	=	0x00000001,
	/// Allows kicking members
	KICK_MEMBERS			=	0x00000002,
	/// Allows banning members
	BAN_MEMBERS				=	0x00000004,
	/// Allows all permissions and bypasses channel permission overwrites
	ADMINISTRATOR			=	0x00000008,
	/// Allows management and editing of channels
	MANAGE_CHANNELS			=	0x00000010,
	/// Allows management and editing of the guild
	MANAGE_GUILD			=	0x00000020,
	/// Allows for the addition of reactions to messages
	ADD_REACTIONS			=	0x00000040,
	/// Allows for viewing of audit logs
	VIEW_AUDIT_LOG			=	0x00000080,
	/// Allows guild members to view a channel, which includes reading messages in text channels
	VIEW_CHANNEL			=	0x00000400,
	/// Allows for sending messages in a channel
	SEND_MESSAGES			=	0x00000800,
	/// Allows for sending of /tts messages
	SEND_TTS_MESSAGES		=	0x00001000,
	/// Allows for deletion of other users messages
	MANAGE_MESSAGES			=	0x00002000,
	/// Links sent by users with this permission will be auto-embedded
	EMBED_LINKS				=	0x00004000,
	/// Allows for uploading images and files
	ATTACH_FILES			=	0x00008000,
	/// Allows for reading of message history
	READ_MESSAGE_HISTORY	=	0x00010000,
	/// Allows for using the \@everyone tag to notify all users in a channel, and the \@here tag to notify all online users in a channel
	MENTION_EVERYONE		=	0x00020000,
	/// Allows the usage of custom emojis from other servers
	USE_EXTERNAL_EMOJIS		=	0x00040000,
	/// Allows for joining of a voice channel
	CONNECT					=	0x00100000,
	/// Allows for speaking in a voice channel
	SPEAK					=	0x00200000,
	/// Allows for muting members in a voice channel
	MUTE_MEMBERS			=	0x00400000,
	/// Allows for deafening of members in a voice channel
	DEAFEN_MEMBERS			=	0x00800000,
	/// Allows for moving of members between voice channels
	MOVE_MEMBERS			=	0x01000000,
	/// Allows for using voice-activity-detection in a voice channel
	USE_VAD					=	0x02000000,
	/// Allows for using priority speaker in a voice channel
	PRIORITY_SPEAKER		=	0x00000100,
	/// Allows for modification of own nickname
	CHANGE_NICKNAME			=	0x04000000,
	/// Allows for modification of other users nicknames
	MANAGE_NICKNAMES		=	0x08000000,
	/// Allows management and editing of roles
	MANAGE_ROLES			=	0x10000000,
	/// Allows management and editing of webhooks
	MANAGE_WEBHOOKS			=	0x20000000,
	/// Allows management and editing of emojis
	MANAGE_EMOJI			=	0x40000000
} permissions;

#define ID(X) X ## "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"

// activity.h

/**
 * @brief Activity types
 *
 * @note Bots are only able to send name, type, and optionally url.
 * @see DiscordActivity_s for detailed element documentation
 */
enum activity_types {
	/// Playing ...
	ACTIVITY_GAME,
	/// Streaming ...
	ACTIVITY_STREAMING,
	/// Listening to ...
	ACTIVITY_LISTENING
};

/**
 * @brief Activity object (game)
 *
 * @note Bots are only able to send name, type, and optionally url.
 * @see DiscordActivity_s for detailed element documentation
 */
typedef struct DiscordActivity_s {
	/// application id for the game
	char application_id[21];
	/// reserved
	uint8_t _type;
	/// guild id of webhook
	/// the activity's name
	char *name;
	/// activity type
	int type;
	/// stream url, required if type is @ref ACTIVITY_STREAMING, only twitch.tv supported
	char *url;
	/// TODO timestamp_x -> timestamps
	/// unix timestamps for start and/or end of the game
	int timestamp_start;

	int timestamp_stop;

	/// what the player is currently doing
	char *details;
	/// the user's current party status
	char *state;

	// information for the current party of the player
	// party object

	// images for the presence and their hover texts
	// assets object

	// secrets for Rich Presence joining and spectating
	// secrets object

	/// whether or not the activity is an instanced game session
	bool instance;
	/// activity flags ORd together, describes what the payload includes
	int flags;
} DiscordActivity;
// user.h

/// User status
enum dscrd_user_status {
	/// Online
	STATUS_ONLINE,
	/// Do not disturb
	STATUS_DND,
	/// AFK
	STATUS_IDLE,
	/// Shown as offline
	STATUS_INVISIBLE,
	/// Offline
	STATUS_OFFLINE
};

/**
 * @brief Discord user.
 *
 * @see DiscordUser_s for detailed element documentation.
 */
typedef struct DiscordUser_s {
	/// the user's id identify
	char id[21];
	/// 
	uint8_t _type;
	/// username, not unique across platform identify
	char * username;
	/// user's 4-digit discord-tag identify
	char discriminator[5];
	/// avatar hash
	char *avatar;
	/// whether the user belongs to an OAuth2 application identify
	bool bot;
	/// whether the user has two factor enabled on their account identify
	bool mfa_enabled;
	/// whether the email on this account has been verified email
	bool verified;
	/// the user's email
	char *email;

	struct DiscordClient_s *discord_client;
} DiscordUser;

/**
 * Get current user information.
 * Returned pointer has to be freed with @ref DiscordUser_destroy.
 * @param client @ref DiscordClient session
 * @returns pointer to @ref DiscordUser_s on success
 * @returns @b NULL on failure
 * @deprecated dscrd gets current user information when opening new client.
 * @deprecated You can access it through @ref DiscordClient.me or @ref DiscordClient.user pointer.
 */
DiscordUser * DiscordUser_me (struct DiscordClient_s *client);

/**
 * Get user information after user id.
 * Returned pointer has to be freed with @ref DiscordUser_destroy.
 * @param client @ref DiscordClient session
 * @param user_id user ID string
 * @returns pointer to @ref DiscordUser_s on success
 * @returns @b NULL on failure
 */
DiscordUser * DiscordUser_get (struct DiscordClient_s *client, char * user_id);
/**
 * Frees DiscordUser pointer.
 * @param user @ref DiscordUser_s pointer
 */
void DiscordUser_destroy (DiscordUser *user);

// client.h

/**
 * Type of the token
 *
 */
typedef enum token_type_e {
	Bearer, Bot, User, Anonymous
} token_type;

#define TOKEN_TO_STR(X) (X == Bearer) ? "Bearer" : (X == Bot) ? "Bot" : (X == User) ? "User" : ""

/**
 * @brief Discord session.
 *
 * You should not access any values except @ref DiscordClient.me / @ref DiscordClient.user and @ref DiscordClient.api
 *
 * @see DiscordClient_s for detailed element documentation.
 * @see DiscordClient_open for getting such session.
 */
typedef struct DiscordClient_s {
	/// reserved
	char _name[21];
	//
	uint8_t _type;
	/// Pointer used internally by rest library, it's casted default to void except in library.
	void *c;
	/// Discord API version used in session.
	/// You can overwrite this by calling @ref dscrd_overwrite_api before creating session.
	unsigned char api;
	/// Session type, one of @ref token_type_e.
	token_type type;
	/// pure token
	char * token;
	/// Authentication header used by rest library.
	char * auth_string;

	/// @ref DiscordUser_s structure of current user; equal to @ref DiscordClient.user except it's a data structure.
	struct DiscordUser_s me;
	/// @ref DiscordUser_s pointer of current user; equal to @ref DiscordClient.me except it's a pointer.
	struct DiscordUser_s *user;

	/// current user status, one of @ref dscrd_user_status
	unsigned char user_status;

	/// tells if created @ref DiscordClient is temporary and has to be freed when connected object is freed.
	bool temporary;
	// ref-count, numebers equal entries dscrd_type_e
	short refc[DSCRD_TYPE_LAST];
	/// pointer to DiscordGateway session (if any)
	void *gateway;
	/// flags
	int gateway_flags;
} DiscordClient;

/**
 * Start Discord session. Every session is bound to specified user/bot.
 * Authentication credentials are passed to this function.
 * @ref DiscordClient is needed for most of the dscrd library functions.
 * After you're done with your session you need to free @ref DiscordClient using @ref DiscordClient_close.
 *
 * @param type type of the token you're passing, one of @ref token_type_e
 * @param token pointer to token string
 * @returns @ref DiscordClient* on success
 * @returns @b NULL on failure
 * @see DiscordClient_close
 */
DiscordClient * DiscordClient_open (token_type type, const char * token);

/**
 * Same as @ref DiscordClient_open but takes @ref DscrdAuth as an argument. It's a macro.
 * @param X pointer to @ref DscrdAuth
 * @returns @ref DiscordClient* on success
 * @returns @b NULL on failure
 * @see DiscordClient_open dscrdd_auth
 */
#define DiscordClient_open_auth(X) DiscordClient_open((X)->type, (X)->token)

/**
 * Close Discord session. You should free any resources allocated with given @ref DiscordClient before you close it.
 * dscrd traces allocations and will notify you if you did not free all resources.
 *
 * @param d pointer to @ref DiscordClient session to close
 * @see DiscordClient_open
 */
void DiscordClient_close (DiscordClient *d);

enum gateway_flags {
	LAZYLOAD_GUILDS = 1,
	// last flags
	GATEWAY_FLAGS_LAST = 2
};

/**
 * Enable Gateway API for specific client.
 * It will try to connect and authenticate to the Discord Gateway API.
 *
 * @param client @ref DiscordClient session
 * @param flags Gateway flags, ORed values of @ref gateway_flags
 * @returns 0 on success
 * @returns NOT 0 on failure
 *
 * @see dscrd_has_gateway()
 */
int DiscordClient_gateway (DiscordClient *client, int flags);

/**
 * Set status for @ref DiscordClient
 *
 * @returns 0 on success
 * @returns NOT 0 on failure
 *
 * @see dscrd_has_gateway()
 * @note This function requires @ref DiscordClient_gateway to be enabled.
 */
int DiscordClient_set_status (DiscordClient *client, enum dscrd_user_status status);

/**
 * Set game for @ref DiscordClient
 *
 * @returns 0 on success
 * @returns NOT 0 on failure
 *
 * @see dscrd_has_gateway()
 * @note This function requires @ref DiscordClient_gateway to be enabled.
 */
int DiscordClient_set_game (DiscordClient *client, DiscordActivity *activity);

// dscrdd.h

/**
 * @ref DscrdAuth structure
 * @see DscrdAuth_s
 */
typedef struct DscrdAuth_s {
	char token[64];
	token_type type;
} DscrdAuth;


/**
 * Try to connect to dscrdd (dscrd daemon) to receive credentials for given app.
 *
 * @param auth pointer to @ref DscrdAuth to write data into
 * @param app_name name of the application
 * @returns 0 on success
 * @returns NOT 0 on failure
 * @todo It's possible that in the future app_name can take password and/or instance number
 * @see dscrdd
 */
int dscrdd_auth (DscrdAuth *auth, const char *app_name);

// guild.h

/**
 * @brief Discord guild.
 *
 * @see DiscordGuild_s for detailed element documentation.
 */
typedef struct DiscordGuild_s {
	/// guild id
	char id[21];
	//
	uint8_t _type;
	/// guild name
	char * name;
	/// icon hash
	char * icon;
	/// splash hash (?)
	char * splash;
	/// whether or not the user is the owner of the guild
	bool owner;
	/// id of owner
	char owner_id[21];
	/// total permissions for the user in the guild (does not include channel overrides)
	int permissions;
	/// voice region id for the guild
	char * region;
	/// id of afk channel
	char afk_channel_id[21];
	/// afk timeout in seconds
	int afk_timeout;
	/// is this guild embeddable (e.g. widget)
	bool embed_enabled;
	/// id of embedded channel
	char embed_channel_id[21];
	/// verification level required for the guild
	int verification_level;
	/// default message notifications level
	int default_message_notifications;
	/// explicit content filter level
	int explicit_content_filter;
	/// roles in the guild
	/*TODO*/ //
	/// emojis
	/*TODO*/ //
	/// features
	char **features;
	/// required MFA level for the guild
	int mfa_level;
	/// application id of the guild creator if it is bot-created
	char application_id[21];
	/// whether or not the server widget is enabled
	bool widget_enabled;
	/// the channel id for the server widget
	char widget_channel_id[21];
	/// the id of the channel to which system messages are sent
	char system_channel_id[21];
	// These fields are only sent within the GUILD_CREATE event:
	/*
	joined_at? *	ISO8601 timestamp	when this guild was joined at
	large? *	bool	whether this is considered a large guild
	unavailable? *	bool	is this guild unavailable
	member_count? *	integer	total number of members in this guild
	voice_states? *	array of partial voice state objects	(without the guild_id key)
	members? *	array of guild member objects	users in the guild
	channels? *	array of channel objects	channels in the guild
	presences? *
	*/
	struct DiscordClient_s *discord_client;
} DiscordGuild;

/**
 * Gets @ref DiscordGuild after specified guild id.
 * You can get guild id manually by enabling discord developer mode (Settings/Apperance/Developer Mode), and right-clicking desired guild.
 * Returned pointer has to be freed with @ref DiscordGuild_destroy.
 * @param client @ref DiscordClient session
 * @param guild_id guild ID
 * @returns pointer to @ref DiscordGuild on success
 * @returns @b NULL on failure
 */
DiscordGuild * DiscordGuild_get (DiscordClient *client, char *guild_id);

/**
 * Gets @ref DiscordGuild after specified guild name.
 * Returned pointer has to be freed with @ref DiscordGuild_destroy.
 * @param client @ref DiscordClient session
 * @param guild_name guild name
 * @returns pointer to @ref DiscordGuild on success
 * @returns @b NULL on failure
 */
DiscordGuild * DiscordGuild_by_name (DiscordClient *client, char *guild_name);

/**
 * Gets @ref DiscordGuild ** for current user.
 * As stated in discord API documentation it will return maximally 100 guilds.
 * Returned pointer has to be freed with @ref DiscordGuilds_destroy.
 * @param client @ref DiscordClient session
 * @returns @ref DiscordGuild ** on success
 * @returns @b NULL on failure
 */
DiscordGuild ** DiscordGuilds_get (DiscordClient *client);

/**
 * Frees @ref DiscordGuild pointer array.
 * @param guild @ref DiscordGuild array
 */
void DiscordGuilds_destroy (DiscordGuild **guilds);

/**
 * Frees @ref DiscordGuild pointer.
 * @param guild @ref DiscordGuild pointer
 */
void DiscordGuild_destroy (DiscordGuild *guild);

// channel.h

/**
 * @brief Discord channel.
 *
 * @see DiscordChannel_s for detailed element documentation.
 * @todo detailed element documentation
 */
typedef struct DiscordChannel_s {
	/// channel ID
	char id[21];
	/// reserved for type detection
	uint8_t _type;
	/// channel type, one of @ref channel_types
	int type;
	/// guild ID channel belongs to
	char guild_id[21];
	/// "sorting position of the channel"
	int position;
	// todo permission overwrites
	char *name;
	char *topic;

	bool nsfw;
	char last_message_id[21];

	int bitrate;
	int user_limit;
	// recipients?
	char *icon;
	char owner_id[21];
	char application_id[21];
	char parent_id[21];
	char *last_pin_timestamp;

	DiscordClient *discord_client;
} DiscordChannel;

typedef struct DiscordChannelList_s {
	int count;
	DiscordChannel **c;
} DiscordChannelList;

/**
 * @brief Channel types
 *
 * Possible types to be found in @ref DiscordChannel.type
 */
enum channel_types {
	GUILD_TEXT, DM, GUILD_VOICE, GROUP_DM, GUILD_CATEGORY
};


/**
 * Gets @ref DiscordChannel after specified channel id.
 * You can get channel id manually by enabling discord developer mode (Settings/Apperance/Developer Mode), and right-clicking desired channel
 *
 * Returned pointer has to be freed with @ref DiscordChannel_destroy.
 * @param client @ref DiscordClient session
 * @param channel_id channel ID
 * @returns pointer to @ref DiscordChannel on success
 * @returns @b NULL on failure
 * @note Friendly reminder: Look forward to not hard-code any channel id in your code.
 */
DiscordChannel * DiscordChannel_get (DiscordClient *client, char *channel_id);

/**
 * Gets @ref DiscordChannel after specified channel id.
 * In comparison to @ref DiscordChannel, this will not load any external information about the channel from Discord servers.
 *
 * Returned pointer has to be freed with @ref DiscordChannel_destroy.
 * @param client @ref DiscordClient session
 * @param channel_id channel ID
 * @returns pointer to @ref DiscordChannel on success
 * @returns @b NULL on failure
 * @see DiscordChannel_get
 */
DiscordChannel * DiscordChannel_get_fast (DiscordClient *client, char *channel_id);

/**
 * Modifies @ref DiscordChannel specified values.
 * Changes are listed in pairs also: "key",(value), ...
 * @param channel @ref DiscordChannel pointer
 * @param ... @b key {"name", ...}
 * @param ... @b value (type depends on key)
 * @param ...
 * @returns 0 on success
 * @returns NOT 0 on failure
 * @todo write this function :)
 */
int DiscordChannel_modify (DiscordChannel *channel, ...);

/**
 * Gets @ref DiscordChannel after specified channel name in specified guild.
 *
 * Returned pointer has to be freed with @ref DiscordChannel_destroy.
 * @param guild @ref DiscordGuild pointer
 * @param channel_name channel name in guild
 * @returns pointer to @ref DiscordChannel on success
 * @returns @b NULL on failure
 */
DiscordChannel * DiscordChannel_by_name (DiscordGuild *guild, char *channel_name);

/**
 * Sends text message to given channel.
 *
 * @param channel @ref DiscordChannel pointer
 * @param message message string
 * @returns 0 on success
 * @returns NOT 0 on failure
 */
int DiscordChannel_send_message_simple (DiscordChannel *channel, const char *message);

/**
 * Gets @ref DiscordChannelList for current user.
 * Returned pointer has to be freed with @ref DiscordChannelList_destroy.
 * @param guild @ref DiscordGuild pointer
 * @returns pointer to @ref DiscordChannelList on success
 * @returns @b NULL on failure
 */
DiscordChannelList * DiscordChannels_in_guild (DiscordGuild *guild);

/**
 * Removes specified element from @ref DiscordChannelList and returns it.
 *
 * @param list @ref DiscordChannelList
 * @param i element number
 * @returns @ref DiscordChannel pointer
 */
DiscordChannel * DiscordChannelList_pop (DiscordChannelList *list, int i);

/**
 * Frees @ref DiscordChannelList pointer.
 * @param channels @ref DiscordChannelList pointer
 */
void DiscordChannelList_destroy (DiscordChannelList *channels);

/**
 * Frees @ref DiscordChannel pointer.
 * @param channel @ref DiscordChannel pointer
 */
void DiscordChannel_destroy (DiscordChannel * channel);

// file.h

/// Use this if you want to reset avatar (needed to distinguish from not changing avatar)
#define DSCRD_FILE_NULL ((DscrdFile *) "dummy")

/**
 * @brief Discord file wrapper.
 *
 * @see DscrdFile_s for detailed element documentation.
 * @todo detailed element documentation
 */
typedef struct DscrdFile_s {
	char head[13];
	uint32_t data_len;
	uint32_t data_base64_len;
	uint8_t _type;
	char *mime;
	char *filename;
	char *data;
	char *data_base64;
	char *encoded;
} DscrdFile;

/**
 * Returns @ref DscrdFile pointer for specified filename.
 * Returned pointer has to be freed with @ref DscrdFile_destroy.
 * @param filename path to file
 * @returns pointer to @ref DscrdFile on success
 * @returns @b NULL on failure
 * @see DscrdFile_get_mime
 */
DscrdFile * DscrdFile_get (const char *filename);

/**
 * Returns @ref DscrdFile pointer for specified filename.
 * In comparsion to @ref DscrdFile_get here you can specify MIME type by yourself
 * Returned pointer has to be freed with @ref DscrdFile_destroy.
 * @param filename path to file
 * @param mime_type MIME-type string 
 * @returns pointer to @ref DscrdFile on success
 * @returns @b NULL on failure
 */
DscrdFile * DscrdFile_get_mime (const char *filename, const char *mime_type);

/**
 * Frees @ref DscrdFile pointer.
 * @param file @ref DscrdFile pointer
 */
void DscrdFile_destroy (DscrdFile *file);

// message.h

typedef struct DiscordMessage_s {
	/// message ID
	char id[21];
	/// reserved
	uint8_t _type;
	/// channel ID
	char channel_id[21];
	/// author
	DiscordUser *author;
	/// contents of the message
	char *content;
	/// when this message was sent
	char *timestamp;
	/// when this message was edited (or null if never)
	char *edited_timestamp;
	/// whether this was a TTS message
	bool tts;
	/// whether this message mentions everyone
	bool mention_everyone;
	/// users specifically mentioned in the message
	DiscordUser **mentions;
	/// roles specifically mentioned in this message
	// TODO roles type //mention_roles
	/// array of attachment objects	any attached files
	// todo //attachments
	///
	// embeds
	/// reactions to the message
	// reactions
	/// used for validating a message was sent
	char nonce[21];
	/// whether this message is pinned
	bool pinned;
	/// if the message is generated by a webhook, this is the webhook's id
	char webhook_id[21];
	/// type of message
	int type;

	// sent with Rich Presence-related chat embeds:
	// activity
	// application

	DiscordClient *discord_client;

} DiscordMessage;

enum message_types {
DEFAULT, RECIPIENT_ADD, RECIPIENT_REMOVE, CALL,
CHANNEL_NAME_CHANGE, CHANNEL_ICON_CHANGE, CHANNEL_PINNED_MESSAGE, GUILD_MEMBER_JOIN
};

/// TODO
int DiscordMessage_callback_all (DiscordClient *client, int (*callback)(DiscordMessage *));

int DiscordMessage_callback_mentions (DiscordClient *client, int (*callback)(DiscordMessage *));

/// Delete message after channel and message id
int DiscordMessage_delete_id (DiscordClient *client, const char *channel_id, const char *message_id);

/// Delete specified message
int DiscordMessage_delete (DiscordMessage *message);

/// new message (returns back)
DiscordMessage * DiscordMessage_new_simple (DiscordChannel *channel, const char *message);

void DiscordMessage_destroy (DiscordMessage *msg);

DiscordMessage * DiscordMessage_get (DiscordChannel *channel, char *message_id);

// webhook.h

/**
 * @brief Webhook structure.
 *
 * @see Webhook_s for detailed element documentation.
 */
typedef struct Webhook_s {
	// id is in snowflake format, 64-bit -> uint64 -> strlen(uint64_max) == 20 bytes + terminating char
	/// id of the webhook
	char id[21];
	//
	uint8_t _type;
	/// guild id of webhook
	char guild_id[21];
	/// channel id for this webhook
	char channel_id[21];
	/// user object	the user this webhook was created by (not returned when getting a webhook with its token)
	DiscordUser user;
	/// same as user but pointer
	DiscordUser *user_p;
	/// the default name of the webhook (optional)
	char * name;
	/// the default avatar of the webhook (optional)
	char * avatar;
	/// the secure token of the webhook
	char token[128];
	/// prefer to use token instead of auth
	bool use_token;
	/// DiscordClient of the Webhook
	DiscordClient *discord_client;
} Webhook;

/**
 * @brief WebhookList structure.
 *
 * @see WebhookList_s for detailed element documentation.
 */
typedef struct WebhookList_s {
	int count;
	Webhook **w;
} WebhookList;

/**
 * Gets @ref Webhook pointer after webhook id.
 * If you have Webhook url you can extract ID by using following schema:
 * @code https://discordapp.com/api/webhooks/{ID}/{TOKEN} @endcode
 * Returned pointer has to be freed with @ref Webhook_destroy.
 * @param client @ref DiscordClient session
 * @param id webhook ID
 * @returns pointer to @ref Webhook on success
 * @returns @b NULL on failure
 * @see Webhook_get_no_auth
 */
Webhook * Webhook_get (DiscordClient *client, char * id);

/**
 * Gets @ref Webhook pointer after webhook id and token.
 * No DiscordClient needed.
 * If you have Webhook url you can extract ID and TOKEN by using following schema:
 * @code https://discordapp.com/api/webhooks/{ID}/{TOKEN} @endcode
 * Returned pointer has to be freed with @ref Webhook_destroy.
 * @param id webhook ID
 * @param token webhook TOKEN
 * @returns pointer to @ref Webhook on success
 * @returns @b NULL on failure
 * @see Webhook_get_no_auth_url
 */
Webhook * Webhook_get_no_auth (char * id, char * token);

/**
 * Gets @ref Webhook pointer after webhook url.
 * No DiscordClient needed.
 * Returned pointer has to be freed with @ref Webhook_destroy.
 * @param url webhook url
 * @returns pointer to @ref Webhook on success
 * @returns @b NULL on failure
 */
Webhook * Webhook_get_no_auth_url (const char * url);

/**
 * Creates new webhook in given channel.
 * Returned pointer has to be freed with @ref Webhook_destroy.
 * @param channel @ref DiscordChannel pointer
 * @param name webhook name
 * @param avatar avatar data
 * @returns pointer to @ref Webhook on success
 * @returns @b NULL on failure
 */
Webhook * Webhook_create (DiscordChannel * channel, char * name, DscrdFile * avatar);

/**
 * Frees @ref Webhook pointer.
 * @param webhook @ref Webhook pointer
 */
void Webhook_destroy (Webhook * webhook);

/**
 * Execute a @ref Webhook (send a message).
 * @param webhook @ref Webhook pointer
 * @param message text content to be sent
 * @param username override default webhook name, can be @b NULL
 * @param avatar_url avatar URL, can be @b NULL
 * @returns 0 on success
 * @returns NOT 0 on failure
 * @see Webhook_execute_simple
 */
int Webhook_execute (Webhook * webhook, const char * message, const char * username, const char * avatar_url);

/**
 * Execute a @ref Webhook and send a message.
 * In comparison to @ref Webhook_execute this function does not allow to change username or avatar
 * @param webhook @ref Webhook pointer
 * @param message text content to be sent
 * @returns 0 on success
 * @returns NOT 0 on failure
 */
int Webhook_execute_simple (Webhook * webhook, const char * message);

/**
 * Deletes @ref Webhook from Discord servers.
 * 
 * @param webhook @ref Webhook pointer
 * @returns 0 on success
 * @returns NOT 0 on failure
 * @warning This function does not free @ref Webhook pointer. To free @ref Webhook pointer use @ref Webhook_destroy.
 * @n
 * @warning This function is not reversible.
 */
int Webhook_delete (Webhook * webhook);

/**
 * Modifies @ref Webhook values.
 * 
 * @param webhook @ref Webhook pointer
 * @param name new name
 * @param avatar @ref DscrdFile pointer to avatar
 * @returns 0 on success
 * @returns NOT 0 on failure
 * @see Webhook_move to move webhook to different channel
 */
int Webhook_modify (Webhook *webhook, const char *name, DscrdFile *avatar);

/**
 * Moves @ref Webhook into different channel.
 * 
 * @param webhook @ref Webhook pointer
 * @param channel @ref DiscordChannel pointer to new channel
 * @returns 0 on success
 * @returns NOT 0 on failure
 */
int Webhook_move (Webhook *webhook, DiscordChannel *channel);

/**
 * Returns list over Webhooks in specified channel.
 * Returned pointer has to be freed with @ref WebhookList_destroy.
 * @param client @ref DiscordClient session
 * @param channel @ref DiscordChannel pointer
 * @returns pointer to @ref WebhookList on success
 * @returns @b NULL on failure
 */
WebhookList * Webhooks_in_channel (DiscordClient *client, DiscordChannel * channel);

/**
 * Returns list over Webhooks in specified guild.
 * Returned pointer has to be freed with @ref WebhookList_destroy.
 * @param client @ref DiscordClient session
 * @param guild @ref DiscordGuild pointer
 * @returns pointer to @ref WebhookList on success
 * @returns @b NULL on failure
 */
WebhookList * Webhooks_in_guild (DiscordClient *client, DiscordGuild *guild);

/**
 * Frees @ref WebhookList pointer.
 * @param list @ref WebhookList pointer
 */
void WebhookList_destroy (WebhookList *list);

// con/gateway.h

struct DiscordGuild_s;


/**
 * Loads lazyloaded @ref DiscordGuild.
 * Returned pointers will be freed automatically on gateway close.
 * @param client @ref DiscordClient session
 * @returns pointer to @ref DiscordGuild  array on success
 * @returns @b NULL on failure
 */
struct DiscordGuild_s ** DiscordClient_lazy_guilds (DiscordClient *client);


typedef struct GatewayResp_s {
	/// response type
	char *event;
	/// data pointer
	void *data;
	/// type of d pointer, one of @ref dscrd_type_e
	int data_type;
	/// tell callback we're finished, free all memory etc.
	unsigned char terminate;
	/// pointer to provided userdata
	void *userdata;
} GatewayResp;

enum gateway_callback_resp {
	CALLBACK_OK,
	CALLBACK_ABORT
};


int DiscordGateway_callback (DiscordClient *client, char *event, int (*func)(GatewayResp *), void *userdata);

